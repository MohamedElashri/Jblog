<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Monte Carlo Simulation of 1d Ising Model | My Blog </title> <meta name="description" content=" Monte Carlo Simulation of a simple 1d Ising Model "> <meta name="keywords" content="Monte Carlo, Ising Model, Python, 1d"> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <!-- Social: Twitter --> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:site" content="MohamedElashri"> <meta name="twitter:title" content=" Monte Carlo Simulation of 1d Ising Model | My Blog "> <meta name="twitter:description" content=" Monte Carlo Simulation of a simple 1d Ising Model "> <meta name="twitter:image:src" content="https://blog.melashri.net"> <!-- Canonical link tag --> <link rel="canonical" href="https://blog.melashri.net/2021/1d-ising-model/"> <link rel="alternate" type="application/rss+xml" title="My Blog" href="https://blog.melashri.net/feed.xml"> <!-- rel prev and next --> <link rel="stylesheet" href="https://blog.melashri.net/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"> </head> <body> <main class="wrapper"> <header class="site-header"> <nav class="nav"> <div class="container"> <h1 class="logo"><a href="https://blog.melashri.net/">My Blog<span></span></a> </h1> <ul class="navbar"> <li><a href="https://blog.melashri.net/about">About</a></li> <li><a href="https://blog.melashri.net/feed.xml" target="_blank">RSS</a></li> </ul> </div> </nav> </header> <article class="post container" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <p class="post-meta"><time datetime="2021-06-01T00:00:00+00:00" itemprop="datePublished">Jun 1, 2021</time></p> <h1 class="post-title" itemprop="name headline">Monte Carlo Simulation of 1d Ising Model</h1> </header> <div class="post-content" itemprop="articleBody"> <ul> <li><a href="#introduction">Introduction</a></li> <li><a href="#monte-carlo-simulation">Monte Carlo Simulation</a></li> <li><a href="#1d-ising-model-simulation">1D Ising Model Simulation</a></li> <li><a href="#ising-model-animation">Ising Model Animation</a></li> <li><a href="#magnetization-and-heat-capacity">Magnetization and heat capacity</a></li> <li><a href="#conclusion">Conclusion</a></li> </ul> <h2 id="introduction">Introduction</h2> <p>The Ising model is a mathematical model used to describe the behavior of a system of ferromagnetic materials. It was first proposed by physicist Wilhelm Lenz in 1920 and has since been widely used to study phase transitions and critical phenomena in statistical mechanics.</p> <p>One way to simulate the 1D Ising model in Python is through the use of the Monte Carlo method. This involves generating a large number of random configurations of the system and using these to estimate the thermodynamic properties of the system.</p> <h2 id="monte-carlo-simulation">Monte Carlo Simulation</h2> <p>Monte Carlo simulation is a statistical method used to model the behavior of a system by generating a large number of random configurations and using these to estimate the probability of certain outcomes. It is commonly used in many fields to analyze complex systems and make predictions about their behavior.</p> <p>To illustrate, consider the problem of estimating the value of π using a Monte Carlo simulation in Python. To do this, we can generate a large number of random points within a square and count the number that fall within a quarter circle inscribed within the square. The probability that a given point will fall within the quarter circle is equal to the ratio of the area of the quarter circle to the area of the square, which is equal to π/4. By dividing the number of points that fall within the quarter circle by the total number of points, we can estimate the value of π. This simple example illustrates the basic idea behind Monte Carlo simulation, which is to use random sampling to estimate the probability of certain outcomes</p> <p>Here is an example of how this could be implemented in Python:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>

<span class="c1"># Number of points to generate
</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">100000</span>

<span class="c1"># Counter for points within the quarter circle
</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># Generate the points
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Check if the point is within the quarter circle
</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># Calculate the estimated value of pi
</span>
<span class="n">pi_estimate</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">count</span> <span class="o">/</span> <span class="n">n</span>
<span class="k">print</span><span class="p">(</span><span class="n">pi_estimate</span><span class="p">)</span>


</code></pre></div></div> <p>The first line imports the <code class="highlighter-rouge">random</code> module, which provides functions for generating random numbers. The next line sets the number of points to generate to 100,000. The following line initializes a counter for the number of points that fall within the quarter circle.</p> <p>The main part of the code is a <code class="highlighter-rouge">for</code> loop that iterates over a range of n values. Within the loop, the code generates two random numbers between -1 and 1 using the <code class="highlighter-rouge">random.uniform()</code> function and assigns them to the variables <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>. These represent the coordinates of a point within the square.</p> <p>The code then checks whether the point is within the quarter circle by checking if <code class="highlighter-rouge">x**2 + y**2 &lt;= 1</code>. If this condition is true, the counter is incremented. This process is repeated for <code class="highlighter-rouge">n</code> iterations, generating <code class="highlighter-rouge">n</code> random points and counting the number that fall within the quarter circle.</p> <p>Finally, the code calculates the estimated value of <code class="highlighter-rouge">π</code> by dividing the count by <code class="highlighter-rouge">n</code> and multiplying by 4. The result is printed to the console using the <code class="highlighter-rouge">print()</code> function.</p> <h2 id="1d-ising-model-simulation">1D Ising Model Simulation</h2> <p>To begin, we will need to import the necessary libraries and define some key variables. The first thing we will need is a way to store the state of the system. We can do this using a list, where each element represents the spin of a particular particle in the system. For simplicity, we will assume that all particles have the same spin.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">generate_random_configuration</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>

    <span class="n">spins</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">spins</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spins</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spins</span>


</code></pre></div></div> <p>Next, we will need to define the energy of each configuration. In the 1D Ising model, the energy of a configuration is given by the sum of the interactions between neighboring particles. For a given configuration, we can calculate the energy by looping through the list of spins and adding up the interactions between each pair of neighboring spins.</p> <p>Once we have a way to store the state of the system and calculate the energy, we can start using the Monte Carlo method to simulate the system. The basic idea is to generate a large number of random configurations and use these to estimate the thermodynamic properties of the system. To do this, we will need to define a function that generates a random configuration of the system. This can be done using a simple loop that flips the spin of each particle with a certain probability.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_energy</span><span class="p">(</span><span class="n">spins</span><span class="p">):</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="o">-</span><span class="n">spins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">spins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">energy</span>

</code></pre></div></div> <p>Next, we will need to define a function that performs a single Monte Carlo step. This involves generating a random configuration, calculating the energy of the configuration, and comparing it to the energy of the current configuration. If the new configuration has a lower energy, we accept it. If the new configuration has a higher energy, we accept it with a probability given by the Boltzmann factor.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">monte_carlo_step</span><span class="p">(</span><span class="n">spins</span><span class="p">,</span> <span class="n">temperature</span><span class="p">):</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span>

    <span class="n">new_spins</span> <span class="o">=</span> <span class="n">spins</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># Choose a random particle
</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Calculate the change in energy due to flipping the spin
</span>
    <span class="n">delta_energy</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">spins</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">spins</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">])</span>
    
    <span class="c1"># Flip the spin with a probability given by the Boltzmann factor
</span>
    <span class="k">if</span> <span class="n">delta_energy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">math</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">delta_energy</span><span class="o">/</span><span class="n">temperature</span><span class="p">):</span>
        <span class="n">new_spins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">spins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">new_spins</span>
</code></pre></div></div> <p>Finally, we will need to define a function that runs the Monte Carlo simulation for a specified number of steps. This can be done by calling the Monte Carlo step function repeatedly until the desired number of steps has been reached.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">monte_carlo_simulation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>

    <span class="c1"># Generate a random initial configuration
</span>
    <span class="n">spins</span> <span class="o">=</span> <span class="n">generate_random_configuration</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    
    <span class="c1"># Perform the Monte Carlo steps
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
        <span class="n">spins</span> <span class="o">=</span> <span class="n">monte_carlo_step</span><span class="p">(</span><span class="n">spins</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">spins</span>
</code></pre></div></div> <p>Now using the implemented function, we can run the simulation with n=10 particles, temperature=1, and steps=1000 and print the final configuration.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">final_configuration</span> <span class="o">=</span> <span class="n">monte_carlo_simulation</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">final_configuration</span><span class="p">)</span>
</code></pre></div></div> <p>The output will be a list of 10 spins , where each element is 1 or -1. The spins will be arranged in a way that minimizes the energy of the system. This is because the Monte Carlo method is designed to find the configuration of the system that minimizes the energy.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
</code></pre></div></div> <p>To summerize the code:</p> <ul> <li> <p><code class="highlighter-rouge">generate_random_configuration()</code>: This function generates a random configuration of the system by randomly flipping the spin of each particle with a certain probability. It takes two arguments: n, the number of particles in the system, and p, the probability of flipping the spin of a particle. It returns a list of n spins, where each element is 1 or -1.</p> </li> <li> <p><code class="highlighter-rouge">calculate_energy()</code>: This function calculates the energy of a given configuration. It takes a single argument, spins, the configuration of the system. It returns the energy of the configuration as a float.</p> </li> <li> <p><code class="highlighter-rouge">monte_carlo_step()</code>: This function performs a single Monte Carlo step. It generates a new configuration by randomly selecting a particle and flipping its spin. The new configuration is accepted with a probability given by the Boltzmann factor. It takes two arguments: <code class="highlighter-rouge">spins</code>, the current configuration of the system, and <code class="highlighter-rouge">temperature</code>, the temperature of the system. It returns the new configuration as a list.</p> </li> <li> <p><code class="highlighter-rouge">monte_carlo_simulation()</code>: This function runs the Monte Carlo simulation for a specified number of steps. It generates a random initial configuration and then repeatedly calls the <code class="highlighter-rouge">monte_carlo_step()</code> function until the desired number of steps has been reached. It takes three arguments: <code class="highlighter-rouge">n</code>, <code class="highlighter-rouge">the number of particles in the system</code>, <code class="highlighter-rouge">temperature</code>, the temperature of the system, and <code class="highlighter-rouge">steps</code>, the number of Monte Carlo steps to perform. It returns the final configuration as a list.</p> </li> </ul> <p>Finally, the code calls the <code class="highlighter-rouge">monte_carlo_simulation()</code> function with <code class="highlighter-rouge">n=10</code>, <code class="highlighter-rouge">temperature=1</code>, and <code class="highlighter-rouge">steps=1000</code> to run the simulation with 10 particles, a temperature of 1, and 1000 Monte Carlo steps. It prints the final configuration to the console using the <code class="highlighter-rouge">print()</code> function.</p> <h2 id="ising-model-animation">Ising Model Animation</h2> <p>To animate the 1D Ising model , we can use a library that provides tools for creating animations, such as <code class="highlighter-rouge">matplotlib</code>, <code class="highlighter-rouge">mayavi</code>, or <code class="highlighter-rouge">plotly</code>. I’m going to use the famous <code class="highlighter-rouge">matplotlib</code> to do this. First we need to import the library</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.animation</span> <span class="k">as</span> <span class="n">animation</span>
</code></pre></div></div> <p>Now we set up the figure and axes</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>
</code></pre></div></div> <p>After that we need to Initialize the data for the plot using the generate_random_configuration() function defined in the previous section. It creates a scatter plot using the scatter function, with the spins as the <code class="highlighter-rouge">y-coordinates</code> and the particle indices as the <code class="highlighter-rouge">x-coordinates</code></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">spins</span> <span class="o">=</span> <span class="n">generate_random_configuration</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">spins</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">spins</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'coolwarm'</span><span class="p">)</span>
</code></pre></div></div> <p>We then create an <code class="highlighter-rouge">update()</code> function, which updates the plot at each frame of the animation. This function performs a single Monte Carlo step using the <code class="highlighter-rouge">monte_carlo_step()</code> function and then updates the scatter plot with the new spin values using the <code class="highlighter-rouge">set_offsets()</code> and <code class="highlighter-rouge">set_array()</code> methods. I was getting <code class="highlighter-rouge">AttributeError: 'list' object has no attribute 'ndim'</code> error because the <code class="highlighter-rouge">scatter.set_array()</code> method expects a numpy array as its argument, but I was passing it a Python list. This causes the <code class="highlighter-rouge">ndim</code> attribute to be accessed on the list object, which does not exist and raises the AttributeError. To fix this, I converted the spins list to a numpy array using the <code class="highlighter-rouge">np.array()</code> function before passing it to the <code class="highlighter-rouge">set_array()</code> method:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Function to update the plot at each frame
</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">spins</span>
    <span class="n">spins</span> <span class="o">=</span> <span class="n">monte_carlo_step</span><span class="p">(</span><span class="n">spins</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">scatter</span><span class="p">.</span><span class="n">set_offsets</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">c_</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">spins</span><span class="p">])</span>
    <span class="n">scatter</span><span class="p">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">spins</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">scatter</span>
</code></pre></div></div> <p>Finally, we create the animation using the <code class="highlighter-rouge">FuncAnimation()</code> function, specifying the figure, the update function, the number of frames, and the blit parameter. It then displays the animation using the <code class="highlighter-rouge">show()</code> function.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create the animation
</span>
<span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="p">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div> <p>PS: If you are using Google colab, it will not show you the animation. The easiest way is to ‘jshtml’ to display matplotlib animation. You need to add the following line of code before the animation code:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">rc</span>
<span class="n">rc</span><span class="p">(</span><span class="s">'animation'</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="s">'jshtml'</span><span class="p">)</span>
</code></pre></div></div> <p>Then, just type your animation object. It will display itself, i.e <code class="highlighter-rouge">anim</code> in this case.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">anim</span>
</code></pre></div></div> <p>Alternatively, you can use <code class="highlighter-rouge">anim.to_html5_video</code> from <code class="highlighter-rouge">IPython.display.HTML</code> using the following code:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span>
<span class="n">HTML</span><span class="p">(</span><span class="n">anim</span><span class="p">.</span><span class="n">to_html5_video</span><span class="p">())</span>
</code></pre></div></div> <p>The outout will be like this:</p> <iframe width="420" height="315" src="/assets/images/posts/1d-ising/animation.mp4" frameborder="0" allowfullscreen=""></iframe> <h2 id="magnetization-and-heat-capacity">Magnetization and heat capacity</h2> <p>To calculate the magnetization and heat capacity of the 1D Ising model, we can define two additional functions in our code:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_magnetization</span><span class="p">(</span><span class="n">spins</span><span class="p">):</span>
    <span class="s">"""Calculate the magnetization of a spin configuration."""</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span>
</code></pre></div></div> <p>The <code class="highlighter-rouge">calculate_magnetization()</code> function takes a spin configuration (a list or array of <code class="highlighter-rouge">1s</code> and <code class="highlighter-rouge">-1s</code>) and returns the mean value of the spins, which is a measure of the overall magnetization of the system.</p> <p>and for the heat capacity:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_heat_capacity</span><span class="p">(</span><span class="n">spins</span><span class="p">,</span> <span class="n">temperature</span><span class="p">):</span>
    <span class="s">"""Calculate the heat capacity of a spin configuration at a given temperature."""</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">calculate_energy</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span>
    <span class="n">magnetization</span> <span class="o">=</span> <span class="n">calculate_magnetization</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span>
    <span class="n">heat_capacity</span> <span class="o">=</span> <span class="p">(</span><span class="n">energy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">magnetization</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">temperature</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">heat_capacity</span>
</code></pre></div></div> <p>The <code class="highlighter-rouge">calculate_heat_capacity()</code> function takes a spin configuration and a temperature, and returns the heat capacity of the system. It calculates the energy and magnetization of the system using the <code class="highlighter-rouge">calculate_energy()</code> and <code class="highlighter-rouge">calculate_magnetization()</code> functions defined earlier, and then uses these values to compute the heat capacity using the formula: <code class="highlighter-rouge">C = (E^2 + M^2) / T^2</code> or <code class="highlighter-rouge">heat_capacity = (energy2 + magnetization2) / temperature**2</code>.</p> <p>We can now use these functions to calculate the magnetization and heat capacity of the system at each step of the animation by calling them in the <code class="highlighter-rouge">update()</code> function:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">spins</span>
    <span class="n">spins</span> <span class="o">=</span> <span class="n">monte_carlo_step</span><span class="p">(</span><span class="n">spins</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">magnetization</span> <span class="o">=</span> <span class="n">calculate_magnetization</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span>
    <span class="n">heat_capacity</span> <span class="o">=</span> <span class="n">calculate_heat_capacity</span><span class="p">(</span><span class="n">spins</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
    <span class="n">scatter</span><span class="p">.</span><span class="n">set_offsets</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">c_</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">spins</span><span class="p">])</span>
    <span class="n">scatter</span><span class="p">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">spins</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">scatter</span>
</code></pre></div></div> <p>We can then use these values to update a plot of the magnetization and heat capacity as the animation progresses. You can create these plots using additional axes on the same figure, or you can create separate figures for each plot. We need to write our animation as a function of temperature. This can be done as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.animation</span> <span class="k">as</span> <span class="n">animation</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">plot_ising_model</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">temperature</span><span class="p">):</span>

    <span class="c1"># Set up the figure and axes
</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">ax1</span><span class="p">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">'1D Ising Model'</span><span class="p">)</span>
    <span class="n">ax1</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Magnetization'</span><span class="p">)</span>
    <span class="n">ax2</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Heat Capacity'</span><span class="p">)</span>

    <span class="c1"># Initialize the data
</span>
    <span class="n">spins</span> <span class="o">=</span> <span class="n">generate_random_configuration</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">spins</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">spins</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'coolwarm'</span><span class="p">)</span>

    <span class="c1"># Set up the magnetization and heat capacity plots
</span>
    <span class="n">magnetization_line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>
    <span class="n">heat_capacity_line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="p">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

    <span class="c1"># Function to update the plots at each frame
</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">spins</span>
        <span class="n">spins</span> <span class="o">=</span> <span class="n">monte_carlo_step</span><span class="p">(</span><span class="n">spins</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
        <span class="n">magnetization</span> <span class="o">=</span> <span class="n">calculate_magnetization</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span>
        <span class="n">heat_capacity</span> <span class="o">=</span> <span class="n">calculate_heat_capacity</span><span class="p">(</span><span class="n">spins</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
        <span class="n">scatter</span><span class="p">.</span><span class="n">set_offsets</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">c_</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">spins</span><span class="p">])</span>
        <span class="n">scatter</span><span class="p">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">spins</span><span class="p">))</span>
        <span class="n">magnetization_line</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">magnetization</span><span class="p">)</span>
        <span class="n">heat_capacity_line</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">heat_capacity</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scatter</span><span class="p">,</span> <span class="n">magnetization_line</span><span class="p">,</span> <span class="n">heat_capacity_line</span>

    <span class="c1"># Create the animation
</span>
    <span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="p">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="c1">#plt.show()
</span></code></pre></div></div> <p>The <code class="highlighter-rouge">plot_ising_model()</code> function takes the number of spins and the temperature as arguments, and creates a figure with two axes. It then creates a scatter plot of the spin configuration, and two line plots for the magnetization and heat capacity. It then defines an <code class="highlighter-rouge">update()</code> function that updates the scatter plot and the two line plots at each frame. Finally, it creates the animation and displays it using the <code class="highlighter-rouge">show()</code> function. To use this function, we can call it with different values of the temperature:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Set the number of particles and the temperature (in units of J/k)
</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">temperature</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Plot the 1D Ising model
</span>
<span class="n">plot_ising_model</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
</code></pre></div></div> <h2 id="conclusion">Conclusion</h2> <p>Ising model is a simple model that can be used to study the phase transition in a system. In this post, we have studied the 1D Ising model using the Monte Carlo method. We have also seen how to create an animation of the system using matplotlib. We have also seen how to calculate the magnetization and heat capacity of the system at each step of the animation. In the next post, we will study the 2D Ising model.</p> </div> </article> <aside id="comments" class="isso"> <div class="container"> <h3><i class="icon icon-comments-o"></i> Comments</h3> <div id="isso_thread"></div> <script data-isso="https://comments.melashri.eu.org/" data-isso-avatar="true" data-isso-vote="true" data-isso-vote-levels="-5,5" src="https://comments.melashri.eu.org/js/embed.min.js"></script> <section id="isso-thread"></section> <noscript> Please enable JavaScript to view the <a href="https://blog.melashri.net" rel="nofollow">comments powered by ISSO.</a> </noscript> </div> </aside> <footer class="site-footer"> <div class="container"> <small class="block">&copy; 2023 Mohamed Elashri &middot; &lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/VerifiedGruber/thinkspace">Thinkspace theme</a></small> </div> </footer> </main> </body> </html>
